# -*- python -*-
# ex: set syntax=python:

# Master builder config for TurnkeyLinux factory running on Outscale and
# EC2-compatible clouds.

# FACTORY PARAMETERS

import logging
import boto
import boto.utils
from outscale_factory_master import utils
import json

REPOS = json.load(open('/etc/tklgit.json'))

# Logging
LOGLEVEL = logging.DEBUG
BOTO_LOGLEVEL = logging.INFO
logging.basicConfig(format='%(levelname)s:%(message)s', level=LOGLEVEL)
logging.getLogger('boto').setLevel(BOTO_LOGLEVEL)

# We use a single builder object customized with properties.
APPLIANCE_BUILDER = 'appliance_builder'

# Full path to the build script on the slave
BUILD_AMI_SCRIPT = "/usr/local/bin/build_ami"

# EC2 credentials
AWS_ID = boto.config.get('Credentials', 'aws_access_key_id')
AWS_KEY = boto.config.get('Credentials', 'aws_secret_access_key')
assert AWS_ID, 'Need aws_access_key_id in $HOME/.boto'
assert AWS_KEY, 'Need aws_secret_access_key in $HOME/.boto'

# EC2 settings
# TODO read from user config
REGION = 'eu-west-1'
LOCATION = 'eu-west-1a'
KEYPAIR = 'a'
SECURITY_GROUP = 'default'

# Master instance info
MASTER = boto.utils.get_instance_metadata()

# Slave instances
# TODO read from user config
MAX_SLAVE_INSTANCES = 30
SLAVE_NAME_PREFIX = 'bot'
# TODO find out the optimal slave size or make it tunable
SLAVE_SIZE = 'm1.large'
SLAVE_AMI = utils.get_image_id(
    REGION,
    'slave-14-07-*')

# Git repo poll interval
REPO_POLL_SEC = 300

# Merge window in seconds for build requests
TREE_STABLE_TIMER_SEC = 120

# The nightly scheduler is basically cron. It triggers a build at a fixed
# time interval.
ENABLE_NIGHTLY_SCHEDULER = False
NIGHTLY_MINUTE = 39
NIGHTLY_HOUR = 23
NIGHTLY_DOM = '*'
NIGHTLY_MONTH = '*'
NIGHTLY_DOW = '*'

# Useful feature but interacts badly with the nightly scheduler
MERGE_BUILD_REQUESTS = False

# Web iface address
#WEB_HOSTNAME = MASTER['public-hostname']
WEB_HOSTNAME = 'localhost'
WEB_PORT = 8010
# Web iface credentials
# TODO read from user config
WEB_LOGIN = 'toto'
WEB_PASSWORD = 'zero'


# BUILDBOT CONFIG

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

# BUILDSLAVES

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
c['slaves'] = []

try:
    # 0.8.8
    from buildbot.buildslave.ec2 import EC2LatentBuildSlave
except ImportError:
    # 0.8.6p1
    from buildbot.ec2buildslave import EC2LatentBuildSlave

for _slave_id in range(0, min(len(REPOS), MAX_SLAVE_INSTANCES)):
    _slave_name = '{}{:03d}'.format(SLAVE_NAME_PREFIX, _slave_id)
    _slave_password = utils.generate_password()
    _slave_user_data = '\n'.join((
        MASTER['public-ipv4'],
        _slave_name,
        _slave_password))
    c['slaves'] += [EC2LatentBuildSlave(_slave_name,
                                        _slave_password,
                                        SLAVE_SIZE,
                                        ami=SLAVE_AMI,
                                        identifier=AWS_ID,
                                        secret_identifier=AWS_KEY,
                                        region=REGION,
                                        keypair_name=KEYPAIR,
                                        security_name=SECURITY_GROUP,
                                        user_data=_slave_user_data,
                                        )]
#del _slave_id, _slave_name, _slave_password, _slave_user_data

# CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

from buildbot.changes.gitpoller import GitPoller

c['change_source'] = []
for _appliance_name, _repourl, _branch in REPOS:
    c['change_source'].append(GitPoller(
        repourl=_repourl,
        project=_appliance_name,
        workdir='gitpoller-' + _appliance_name,
        branch=_branch,
        pollinterval=REPO_POLL_SEC))
#del _appliance_name, _repourl, _branch

# SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.schedulers import timed
from buildbot.changes import filter

c['schedulers'] = []
c['schedulers'].append(ForceScheduler(
    name="force",
    builderNames=[APPLIANCE_BUILDER]))

# For some reason the nightly scheduler does not set the *repository* property.
# We cannot set it ourselves either.
# Set a custom repourl property and use that in the build steps.

for _appliance_name, _repourl, _branch in REPOS:
    _sched_name = '{}-{}'.format(_appliance_name, _branch)
    _sched_props = dict(
        appliance_name=_appliance_name,
        repourl=_repourl
    )
    _sched_filter = filter.ChangeFilter(
        project=_appliance_name,
        branch=_branch
    )
    c['schedulers'].append(SingleBranchScheduler(
        name=_sched_name,
        builderNames=[APPLIANCE_BUILDER],
        change_filter=_sched_filter,
        properties=_sched_props,
        treeStableTimer=TREE_STABLE_TIMER_SEC,
    ))

    if not ENABLE_NIGHTLY_SCHEDULER:
        continue
    c['schedulers'].append(timed.Nightly(
        name='nightly-{}'.format(_sched_name),
        builderNames=[APPLIANCE_BUILDER],
        branch=_branch,
        change_filter=_sched_filter,
        properties=_sched_props,
        minute=NIGHTLY_MINUTE,
        hour=NIGHTLY_HOUR,
        dayOfMonth=NIGHTLY_DOM,
        month=NIGHTLY_MONTH,
        dayOfWeek=NIGHTLY_DOW,
        onlyIfChanged=False,
        onlyImportant=False,
        fileIsImportant=None,
    ))
#del _appliance_name, _repourl, _branch
#del _sched_name, _sched_props, _sched_filter

# BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.process.properties import Property, WithProperties
from buildbot.config import BuilderConfig
from outscale_factory_master import buildsteps

factory = BuildFactory()
_ec2args = dict(
    region=REGION,
    location=LOCATION)
_buildEnv = dict(
    FAB_APT_PROXY = 'http://{public-ipv4}:3142'.format(**MASTER),
    FAB_HTTP_PROXY = 'http://{public-ipv4}:8124'.format(**MASTER))
_buildPy = [
    "/usr/bin/python3",
    BUILD_AMI_SCRIPT,
    "--verbose",
    "--verbose",
    WithProperties("--turnkey-app=%s", "appliance_name"),
    WithProperties("--mount-point=/srv/rootfs/%s/mnt", "appliance_name"),
    WithProperties("--work-dir=/srv/rootfs/%s/patch", "appliance_name"),
    WithProperties("--device=%s", "device_name"),
    ]

factory.addStep(Git(
    haltOnFailure=True,
    name='git clone',
    repourl=Property('repourl'),
    workdir=WithProperties('/turnkey/fab/products/%s', 'appliance_name'),
    mode='incremental',
    submodules=True))

factory.addStep(buildsteps.AttachNewVolume(
    haltOnFailure=True,
    name='AttachNewVolume',
    **_ec2args))

factory.addStep(ShellCommand(
    haltOnFailure=True,
    name='build.py --build-only',
    command=_buildPy + ['--build-only'],
    env=_buildEnv))

factory.addStep(buildsteps.CreateImage(
    haltOnFailure=True,
    name='CreateImage',
    **_ec2args))

factory.addStep(buildsteps.DestroyVolume(
    alwaysRun=True,
    haltOnFailure=False,
    name='DestroyVolume',
    **_ec2args))

factory.addStep(ShellCommand(
    alwaysRun=False,
    haltOnFailure=False,
    name='build.py --clean-only',
    command=_buildPy + ['--clean-only'],
    env=_buildEnv))

#del _buildPy, _buildEnv, _ec2args

c['builders'] = []
c['builders'].append(
    BuilderConfig(name=APPLIANCE_BUILDER,
                  slavenames=[latent.slavename for latent in c['slaves']],
                  factory=factory,
                  mergeRequests=MERGE_BUILD_REQUESTS))

# STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth

authz_cfg = authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth([(WEB_LOGIN, WEB_PASSWORD)]),
    gracefulShutdown=False,
    forceBuild='auth',  # use this to test your slave once it is set up
    forceAllBuilds='auth',
    pingBuilder='auth',
    stopBuild='auth',
    stopAllBuilds='auth',
    cancelPendingBuild='auth',
)
c['status'].append(html.WebStatus(http_port=WEB_PORT, authz=authz_cfg))

# PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Outscale Factory"
c['titleURL'] = "http://www.outscale.com"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://{}:{}/".format(WEB_HOSTNAME, WEB_PORT)

# DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url': "sqlite:///state.sqlite",
}
